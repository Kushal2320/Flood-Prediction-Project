"""
temp.py

Provides a function `predict_flood_for_city(city: str) -> dict` which:
 - fetches weather from OpenWeather (requires OPENWEATHER_API_KEY or OPENWEATHER_KEY env var)
 - aggregates rainfall signals (1h, 3h, 24h, 7d if possible)
 - computes a simple, explainable predicted flood 'level' (meters) using a lightweight formula
 - returns a dict with keys: city, prediction (float), status (string), weather (raw), checklist (string)

If GOOGLE/Gemini key (GEMINI_API_KEY) is present and google.generativeai is installed,
the checklist will be generated by Gemini. Otherwise a fallback checklist template is used.

This file is safe to import (it does not run as a script on import). When run as a script it prints a sample result.
"""

import os
import sys
import time
import requests
import json
from typing import Dict, Any, Optional
from dotenv import load_dotenv

# optional: google generative ai (Gemini) - only used if GEMINI_API_KEY present
try:
    import google.generativeai as genai  # type: ignore
    HAS_GENAI = True
except Exception:
    HAS_GENAI = False

load_dotenv()

# Accept either name for convenience
OPENWEATHER_API_KEY = os.getenv("OPENWEATHER_API_KEY") or os.getenv("OPENWEATHER_KEY")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

if GEMINI_API_KEY and HAS_GENAI:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
    except Exception:
        # continue; we'll fallback to template if errors occur at generation time
        pass


# -------------------------
# Helpers: OpenWeather fetch
# -------------------------
def fetch_openweather_by_city(city: str, limit: int = 1) -> Dict[str, Any]:
    """
    Uses OpenWeather's 'weather' (current) + 'onecall' (for hourly) if possible.
    Returns a dict with keys: current (raw), hourly (list) where present.
    Raises ValueError on missing API key or HTTP errors.
    """
    if not OPENWEATHER_API_KEY:
        raise ValueError("OpenWeather API key not set. Provide OPENWEATHER_API_KEY or OPENWEATHER_KEY in env.")

    # First: geocode by city name using OpenWeather 'weather' endpoint which returns coords
    url_cur = "https://api.openweathermap.org/data/2.5/weather"
    params_cur = {"q": city + ",IN", "appid": OPENWEATHER_API_KEY, "units": "metric"}
    r = requests.get(url_cur, params=params_cur, timeout=12)
    if r.status_code != 200:
        # try a more permissive geocode via Nominatim as fallback
        raise ValueError(f"OpenWeather 'weather' API error: {r.status_code} {r.text}")

    cur = r.json()
    lat = cur.get("coord", {}).get("lat")
    lon = cur.get("coord", {}).get("lon")

    out = {"current": cur, "lat": lat, "lon": lon}

    # Try OneCall / OneCall 3.0 or 2.5 for hourly and daily (use 2.5 endpoint that's widely available)
    try:
        url_one = "https://api.openweathermap.org/data/2.5/onecall"
        params_one = {
            "lat": lat,
            "lon": lon,
            "exclude": "minutely",
            "appid": OPENWEATHER_API_KEY,
            "units": "metric",
        }
        r2 = requests.get(url_one, params=params_one, timeout=15)
        if r2.status_code == 200:
            out_one = r2.json()
            out["onecall"] = out_one
            # normalize hourly/daily if present
            out["hourly"] = out_one.get("hourly", [])
            out["daily"] = out_one.get("daily", [])
        else:
            # fallback: sometimes onecall not available; keep only current
            out["hourly"] = []
            out["daily"] = []
    except Exception:
        out["hourly"] = []
        out["daily"] = []

    return out


# -------------------------
# Aggregate rainfall signals
# -------------------------
def aggregate_rain_signals(weather_payload: Dict[str, Any]) -> Dict[str, float]:
    """
    Returns a dict with:
      - rain_1h_mm
      - rain_3h_mm
      - rain_24h_mm
      - rain_7d_mm
    Best-effort from OpenWeather 'onecall' hourly or from current.rain.
    """
    hourly = weather_payload.get("hourly", [])
    current = weather_payload.get("current", {})

    def hourly_rain(i: int) -> float:
        try:
            h = hourly[i]
            if not h:
                return 0.0
            # OpenWeather hourly rain value may be {"rain":{"1h": <val>}}
            return float(h.get("rain", {}).get("1h", 0.0))
        except Exception:
            return 0.0

    # 1h
    rain_1h = 0.0
    try:
        rain_1h = float(current.get("rain", {}).get("1h", 0.0))
    except Exception:
        try:
            rain_1h = hourly_rain(0)
        except Exception:
            rain_1h = 0.0

    # 3h
    rain_3h = sum(hourly_rain(i) for i in range(0, min(3, len(hourly))))

    # 24h
    rain_24h = sum(hourly_rain(i) for i in range(0, min(24, len(hourly))))

    # 7d: try hourly if enough data (rare) else daily
    if len(hourly) >= 24:
        limit = min(len(hourly), 24 * 7)
        rain_7d = sum(hourly_rain(i) for i in range(limit))
    else:
        daily = weather_payload.get("daily", [])
        rain_7d = sum(float(d.get("rain", 0.0)) for d in daily[:7]) if daily else 0.0

    return {
        "rain_1h_mm": round(rain_1h, 2),
        "rain_3h_mm": round(rain_3h, 2),
        "rain_24h_mm": round(rain_24h, 2),
        "rain_7d_mm": round(rain_7d, 2),
    }


# -------------------------
# Lightweight prediction engine
# -------------------------
def compute_predicted_level(signals: Dict[str, float], weather_current: Dict[str, Any]) -> Dict[str, Any]:
    """
    Compute a simple predicted 'flood level' in meters using an explainable formula.
    This is NOT a hydraulic model; it's a pragmatic surrogate combining short-term intensity + accumulated rainfall + humidity.
    Returns dict with prediction (float, meters) and score (0-100) and reasons list.
    """
    r3 = float(signals.get("rain_3h_mm", 0.0))
    r24 = float(signals.get("rain_24h_mm", 0.0))
    r7 = float(signals.get("rain_7d_mm", 0.0))
    humidity = float(weather_current.get("humidity", weather_current.get("main", {}).get("humidity", 0)) or 0)

    # Simple weighted formula (tunable)
    pred_m = (r3 * 0.018) + (r24 * 0.006) + (r7 * 0.002) + (humidity * 0.0012)
    # small baseline floor
    pred_m = max(0.0, pred_m)

    # Score (0-100) emphasizing short-term intensity
    score = min(100, int(round((r3 * 2.2) + (r24 * 0.9) + (r7 * 0.25))))

    reasons = []
    if r3 >= 50:
        reasons.append(f"High short-term rainfall: {r3} mm in last 3h")
    if r24 >= 100:
        reasons.append(f"Very high 24h rainfall: {r24} mm")
    if r7 >= 200:
        reasons.append(f"High antecedent rainfall (7d): {r7} mm")
    if humidity >= 85:
        reasons.append(f"High humidity: {humidity}% (soil likely saturated)")
    if not reasons:
        reasons.append("No extreme signals detected; conditions appear normal")

    return {
        "prediction_m": round(pred_m, 3),
        "score": int(score),
        "reasons": reasons,
    }


# -------------------------
# AI checklist (Gemini optional)
# -------------------------
def generate_ai_checklist(weather_payload: Dict[str, Any], predicted_level: float, status: str) -> str:
    """
    If GEMINI_API_KEY present and google.generativeai installed, call it to generate a short checklist.
    Otherwise return a deterministic template checklist.
    """
    city_desc = f"Predicted flood level: {predicted_level:.2f} m â€” {status}"
    # Try Gemini if available
    if GEMINI_API_KEY and HAS_GENAI:
        try:
            prompt = (
                f"City weather summary: {json.dumps(weather_payload.get('current', {}), indent=None)[:1500]}\n\n"
                f"{city_desc}\n\n"
                "Provide a short, clear 6-item emergency checklist for residents (bullet points). Keep it concise."
            )
            model = "gemini-pro"  # feel free to change based on availability
            # genai.generate may differ by version; use .generate_text if available; otherwise adjust.
            resp = genai.generate_text(model=model, prompt=prompt, max_output_tokens=256)
            # the response object shape can differ; attempt common attributes
            text = ""
            if getattr(resp, "text", None):
                text = resp.text
            elif isinstance(resp, dict):
                # older sdk might return dict; try common keys
                text = resp.get("candidates", [{}])[0].get("content", "")
            else:
                text = str(resp)
            if text:
                return text.strip()
        except Exception as e:
            # fallback to template
            pass

    # Fallback deterministic checklist
    checklist = []
    checklist.append("1) Move to higher ground immediately if you observe rising water levels.")
    checklist.append("2) Avoid walking or driving through flood water â€” 30 cm of flowing water can move a person, 60 cm can move a car.")
    checklist.append("3) Keep mobile devices charged; share your location with trusted contacts.")
    checklist.append("4) Bring medications, IDs, and emergency essentials in a waterproof bag.")
    checklist.append("5) Follow local authority instructions; move to the nearest evacuation centre if told to do so.")
    checklist.append("6) If trapped, call local emergency services and try to get to the highest safe point in the building.")
    return "\n".join(checklist)


# -------------------------
# Public function
# -------------------------
def predict_flood_for_city(city: str) -> Dict[str, Any]:
    """
    Main entry: given a city name (string), returns:
      {
        "city": <str>,
        "prediction": <float meters>,
        "score": <int 0-100>,
        "status": <'ðŸš¨ FLOOD WARNING' | 'âœ… SAFE'>,
        "reasons": [ ... ],
        "signals": { rain_1h_mm, rain_3h_mm, rain_24h_mm, rain_7d_mm },
        "weather": <raw weather payload (current and onecall if available)>,
        "checklist": <string>
      }
    """
    # 1) fetch weather
    weather_payload = fetch_openweather_by_city(city)

    # 2) compute signals
    signals = aggregate_rain_signals(weather_payload)

    # 3) compute predicted level and score
    result = compute_predicted_level(signals, weather_payload.get("current", {}))
    pred_m = result["prediction_m"]
    score = result["score"]
    reasons = result["reasons"]

    # 4) decide status threshold (tunable)
    # Default threshold: predicted water level > 1.5 m -> warning (simple surrogate)
    status = "ðŸš¨ FLOOD WARNING" if pred_m > 1.5 else "âœ… SAFE"

    # 5) generate checklist (Gemini optional)
    checklist = generate_ai_checklist(weather_payload, pred_m, status)

    return {
        "city": city,
        "prediction": float(pred_m),
        "score": int(score),
        "status": status,
        "reasons": reasons,
        "signals": signals,
        "weather": {
            "current": weather_payload.get("current", {}),
            # don't embed full hourly/daily to keep payload compact if desired; include some bytes
            "hourly_count": len(weather_payload.get("hourly", []) or []),
            "daily_count": len(weather_payload.get("daily", []) or []),
        },
        "checklist": checklist,
    }


# -------------------------
# CLI support: python temp.py Mumbai
# -------------------------
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python temp.py <CityName>")
        sys.exit(1)
    city_name = " ".join(sys.argv[1:])
    try:
        out = predict_flood_for_city(city_name)
        print(json.dumps(out, indent=2, ensure_ascii=False))
    except Exception as exc:
        print("Error:", exc)
        sys.exit(2)
